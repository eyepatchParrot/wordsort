
--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         6291456 B, 64 B, 12-way associative
Command:          ./Prof6 z2e6
Data file:        cachegrind.out.15651
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   /u/v/a/van-sandt/dev/fsort/6/trie.c
                  /u/v/a/van-sandt/dev/fsort/6/entry.c
                  /u/v/a/van-sandt/dev/fsort/6/branch.c
Auto-annotation:  off

--------------------------------------------------------------------------------
         Ir  I1mr  ILmr          Dr       D1mr      DLmr         Dw      D1mw      DLmw 
--------------------------------------------------------------------------------
562,593,055 1,257 1,252 137,344,595 17,030,632 8,464,323 92,613,589 8,286,213 4,338,885  PROGRAM TOTALS

--------------------------------------------------------------------------------
         Ir I1mr ILmr         Dr      D1mr      DLmr         Dw      D1mw      DLmw  file:function
--------------------------------------------------------------------------------
104,218,110    5    5 23,159,580 2,573,278     1,252 15,439,720       470         3  /u/v/a/van-sandt/dev/fsort/6/branch.c:branch_leaf_pull2
 96,690,707    8    8 18,314,259     2,362        14 16,370,625     1,062        11  /u/v/a/van-sandt/dev/fsort/6/trie.c:trie_flush
 78,721,922    8    8 22,402,541 3,514,034 1,983,355 10,383,321 1,998,730       912  /u/v/a/van-sandt/dev/fsort/6/entry.c:entry_bucket2
 64,644,461    5    5 18,172,130 4,986,120 3,469,548 16,164,380 3,542,015 3,538,933  /build/eglibc-oGUzwX/eglibc-2.19/string/../sysdeps/x86_64/multiarch/memcpy-sse2-unaligned.S:__memcpy_sse2_unaligned
 50,002,970    7    7  2,000,494 2,000,000 1,999,999  8,000,498   500,000     1,854  /u/v/a/van-sandt/dev/fsort/6/main.c:tokenizeLast
 30,000,000    3    3  4,000,000   499,998   499,998          0         0         0  /build/eglibc-oGUzwX/eglibc-2.19/string/../sysdeps/x86_64/memrchr.S:memrchr
 23,579,790    0    0 15,719,860 2,823,546   503,596          0         0         0  /u/v/a/van-sandt/dev/fsort/6/hash.c:lhash2
 21,168,112    4    4  2,278,574    36,587         0  4,158,507     3,843         0  /u/v/a/van-sandt/dev/fsort/6/entry.c:entry_sortBuf2
 14,451,584    0    0  8,258,048         0         0  6,193,536     6,651       365  /u/v/a/van-sandt/dev/fsort/6/entry.c:entry_init
 14,126,852    4    4  2,026,908   442,691         0  2,026,908         0         0  /u/v/a/van-sandt/dev/fsort/6/entry.c:entry_dump
 12,283,053    9    9  3,335,098         0         0  2,030,606    13,582        16  /build/eglibc-oGUzwX/eglibc-2.19/stdlib/msort.c:msort_with_tmp.part.0
 10,000,000    0    0  2,000,000         0         0  2,000,000         0         0  /usr/include/x86_64-linux-gnu/bits/string3.h:entry_dump
  7,434,660    6    6  1,115,199         0         0  1,982,576     7,686         0  /build/eglibc-oGUzwX/eglibc-2.19/stdlib/msort.c:qsort_r
  4,817,662    5    5    782,208         0         0    588,660         0         0  /build/eglibc-oGUzwX/eglibc-2.19/string/../sysdeps/x86_64/multiarch/../memcpy.S:__GI_memcpy
  4,270,025   30   26  4,269,881    17,703         9         59         3         1  ???:???
  4,129,024    1    1  2,064,512     1,024         0  2,064,512 1,956,257   791,657  /usr/include/x86_64-linux-gnu/bits/string3.h:entry_init
  4,000,000    0    0  2,000,000         0         0  2,000,000         0         0  /usr/include/x86_64-linux-gnu/bits/string3.h:tokenizeLast
  3,810,164   10   10    943,722    14,929         7    534,305       255       236  /u/v/a/van-sandt/dev/fsort/6/branch.c:branch_leaf_pull
  2,481,192    4    4    843,381    10,095         0    403,074         9         0  /u/v/a/van-sandt/dev/fsort/6/branch.c:branch_pull
  2,002,852   10   10    646,036     1,377       114    568,590     1,332     1,283  /u/v/a/van-sandt/dev/fsort/6/branch.c:branch_leaf_grow
  1,797,968    4    4      3,845         1         0  1,007,636   248,065     2,112  /build/eglibc-oGUzwX/eglibc-2.19/string/../sysdeps/x86_64/memset.S:memset
  1,479,940    0    0    492,032    14,453         0          0         0         0  /usr/lib/gcc/x86_64-linux-gnu/4.8/include/avx2intrin.h:entry_bucket2
  1,227,263    1    1    937,621    25,658         0          0         0         0  /u/v/a/van-sandt/dev/fsort/6/entry.c:smallentry_hcmp
    929,402    5    5    384,405     8,314         5        120         0         0  /build/eglibc-oGUzwX/eglibc-2.19/malloc/malloc.c:free
    906,003    3    3     65,079        22         0    258,741        57         0  /u/v/a/van-sandt/dev/fsort/6/entry.c:entry_pop
    802,919   61   61     97,297       601        19    125,317     4,150       663  /build/eglibc-oGUzwX/eglibc-2.19/malloc/malloc.c:_int_malloc
    590,391    1    1    262,396         0         0    131,198         0         0  /u/v/a/van-sandt/dev/fsort/6/leaf.c:leaf_put

--------------------------------------------------------------------------------
-- User-annotated source: /u/v/a/van-sandt/dev/fsort/6/trie.c
--------------------------------------------------------------------------------
        Ir I1mr ILmr        Dr D1mr DLmr        Dw D1mw DLmw 

-- line 5 ----------------------------------------
         .    .    .         .    .    .         .    .    .  #include <stdlib.h>
         .    .    .         .    .    .         .    .    .  #include <string.h>
         .    .    .         .    .    .         .    .    .  
         .    .    .         .    .    .         .    .    .  #include "constants.h"
         .    .    .         .    .    .         .    .    .  #include "sort.h"
         .    .    .         .    .    .         .    .    .  #include "leaf.h"
         .    .    .         .    .    .         .    .    .  
         .    .    .         .    .    .         .    .    .  void trie_init(Trie* t) {
         1    1    1         0    0    0         1    1    0  	t->root.type = TYPE_NONE;
         2    0    0         1    0    0         1    0    0  	t->root.ptr.l = NULL;
         .    .    .         .    .    .         .    .    .  }
         .    .    .         .    .    .         .    .    .  
         2    0    0         0    0    0         1    0    0  void trie_delete(Trie* t) {
         8    1    1         1    1    1         0    0    0  	switch (t->root.type) {
         .    .    .         .    .    .         .    .    .  		case TYPE_LEAF:
         .    .    .         .    .    .         .    .    .  			free(t->root.ptr.l);
         .    .    .         .    .    .         .    .    .  			break;
         .    .    .         .    .    .         .    .    .  
         .    .    .         .    .    .         .    .    .  		case TYPE_BRANCH:
         .    .    .         .    .    .         .    .    .  			branch_delete(t->root.ptr.b);
         .    .    .         .    .    .         .    .    .  			free(t->root.ptr.b);
         .    .    .         .    .    .         .    .    .  			break;
         .    .    .         .    .    .         .    .    .  
         .    .    .         .    .    .         .    .    .  		case TYPE_BRANCHLEAF:
         .    .    .         .    .    .         .    .    .  			branch_leaf_delete(t->root.ptr.bl);
         .    .    .         .    .    .         .    .    .  			free(t->root.ptr.bl);
         .    .    .         .    .    .         .    .    .  			break;
         .    .    .         .    .    .         .    .    .  
         .    .    .         .    .    .         .    .    .  		case TYPE_BRANCHLEAF2:
         2    0    0         1    0    0         1    0    0  			branch_leaf_delete2(t->root.ptr.bl2);
         2    0    0         1    1    0         0    0    0  			free(t->root.ptr.bl2);
         .    .    .         .    .    .         .    .    .  			break;
         .    .    .         .    .    .         .    .    .  
         .    .    .         .    .    .         .    .    .  		default:
         .    .    .         .    .    .         .    .    .  			assert(0);
         .    .    .         .    .    .         .    .    .  	}
         1    0    0         1    0    0         0    0    0  }
         .    .    .         .    .    .         .    .    .  
         .    .    .         .    .    .         .    .    .  #ifdef PROF_STACK
         .    .    .         .    .    .         .    .    .  // have a flush for each width buffer where width is the number of chars hashed
         .    .    .         .    .    .         .    .    .  // have a flush for full buffers and partial ones
     4,401    1    1         0    0    0     2,445  488    5  void trie_flush(Trie *t, Entry* buf, unsigned bufSz) {
         .    .    .         .    .    .         .    .    .  	// consolidate different size stacks into the highest size stack
         .    .    .         .    .    .         .    .    .  	// draw an entry pointer up from leaves and branches passing in only the next
         .    .    .         .    .    .         .    .    .  	// hash. 
         .    .    .         .    .    .         .    .    .  	// flush will allow us to have the trie start out as a leaf node. since the
         .    .    .         .    .    .         .    .    .  	// indirection won't be costly
         .    .    .         .    .    .         .    .    .  	// Squash tree to reduce indirection.
         .    .    .         .    .    .         .    .    .  	assert(t != NULL);
         .    .    .         .    .    .         .    .    .  	// TODO look at the asm for this loop
         .    .    .         .    .    .         .    .    .  	static void* freeBuf[BUF_SZ];
         .    .    .         .    .    .         .    .    .  	static pull_fn pull_table[] = {0, 0, 0, branch_pull, branch_leaf_pull, branch_leaf_pull2 };
         .    .    .         .    .    .         .    .    .  	static hash_fn hash_table[] = {0, 0, 0, lhash, lhash, lhash2 };
         .    .    .         .    .    .         .    .    .  	int freeBufSz = 0;
     1,467    1    1       489  489    1         0    0    0  	if (t->root.type == TYPE_NONE) {
         1    1    1         0    0    0         1    0    0  		t->root.type = TYPE_LEAF;
         8    1    1         2    0    0         4    1    0  		t->root.ptr.l = leaf_new();
         .    .    .         .    .    .         .    .    .  	}
 4,003,423    0    0         0    0    0         0    0    0  	for (int i = 0; i < bufSz; ++i) {
         .    .    .         .    .    .         .    .    .  		Entry* e = buf + i;
 2,000,000    0    0         0    0    0 2,000,000  487    5  		int depth = 0;
 8,000,000    0    0 4,000,000   14    0 4,000,000    0    0  		Node n = t->root;
17,721,904    1    1 2,000,000    0    0         0    0    0  		switch (n.type) {
         .    .    .         .    .    .         .    .    .  			case TYPE_LEAF:
         .    .    .         .    .    .         .    .    .  				{
     1,025    1    1     1,025    0    0         0    0    0  					Leaf* oldL = t->root.ptr.l;
   148,270    0    0   142,120    0    0     1,025    0    0  					if (leaf_grow(&t->root, t->root.ptr.l, t->root.ptr.l->sz, t->root.ptr.l->capacity, 0)) {
         2    1    1         0    0    0         1    0    0  						free(oldL);
         7    0    0         4    0    0         2    1    0  						n = t->root;
         .    .    .         .    .    .         .    .    .  					}
         .    .    .         .    .    .         .    .    .  				}
         .    .    .         .    .    .         .    .    .  				break;
         .    .    .         .    .    .         .    .    .  			case TYPE_BRANCH:
         3    0    0         2    0    0         1    0    0  				n = branch_grow(n);
         .    .    .         .    .    .         .    .    .  				t->root = n;
         .    .    .         .    .    .         .    .    .  				break;
         .    .    .         .    .    .         .    .    .  			case TYPE_BRANCHLEAF:
   414,062    0    0   138,020    0    0   207,032    2    1  				n = branch_leaf_grow(n);
   207,033    0    0         0    0    0   138,022    1    0  				t->root = n;
    70,035    0    0         0    0    0         0    0    0  				break;
         .    .    .         .    .    .         .    .    .  
         .    .    .         .    .    .         .    .    .  			default:
         .    .    .         .    .    .         .    .    .  				break;
         .    .    .         .    .    .         .    .    .  		}
16,023,116    1    1 4,011,046    0    0         0    0    0  		while (n.type >= TYPE_BRANCH || n.type == TYPE_BRANCHLEAF || n.type == TYPE_BRANCHLEAF2) {
         .    .    .         .    .    .         .    .    .  			hash2_t h;
18,049,707    0    0 2,005,523  557    4 2,005,523    0    0  			h = hash_table[n.type](e->h + (depth % NUM_HASHES));
14,038,661    0    0 4,011,046  557    4 6,016,569   82    0  			n = pull_table[n.type](&n, h, &depth);
         .    .    .         .    .    .         .    .    .  
         .    .    .         .    .    .         .    .    .  			assert((depth % NUM_HASHES) != 0);
         .    .    .         .    .    .         .    .    .  		}
         .    .    .         .    .    .         .    .    .  
         .    .    .         .    .    .         .    .    .  		hash_t* hBuf;
 4,000,000    0    0         0    0    0         0    0    0  		if (depth % NUM_HASHES == 0) {
     3,072    0    0     2,048  256    0         0    0    0  			hBuf = (hash_t*)e->nl + e->off + depth;
         .    .    .         .    .    .         .    .    .  		} else {
         .    .    .         .    .    .         .    .    .  			hBuf = e->h;
         .    .    .         .    .    .         .    .    .  		}
         .    .    .         .    .    .         .    .    .  		assert(n.type == TYPE_LEAF || n.type == TYPE_ENTRY);
 4,000,000    0    0         0    0    0         0    0    0  		if (n.type == TYPE_LEAF) {
 4,002,174    0    0 2,000,000    0    0     1,087    0    0  			leaf_put(n.ptr.l, hBuf, e);
         .    .    .         .    .    .         .    .    .  		} else {
         .    .    .         .    .    .         .    .    .  			// TODO rename to entry_set
 3,998,913    0    0         0    0    0 1,998,913    0    0  			entry_init(n.ptr.e, hBuf, e);
         .    .    .         .    .    .         .    .    .  		}
         .    .    .         .    .    .         .    .    .  	}
         .    .    .         .    .    .         .    .    .  	for (int i = 0; i < freeBufSz; i++) {
         .    .    .         .    .    .         .    .    .  		free(freeBuf[i]);
         .    .    .         .    .    .         .    .    .  	}
     3,423    0    0     2,934  489    5         0    0    0  }
         .    .    .         .    .    .         .    .    .  #endif
         .    .    .         .    .    .         .    .    .  
         .    .    .         .    .    .         .    .    .  void trie_dump(Trie* t, char* output) {
         .    .    .         .    .    .         .    .    .  	// consider making this work off of pull as well
         8    0    0         1    0    0         0    0    0  	switch (t->root.type) {
         .    .    .         .    .    .         .    .    .  		case TYPE_LEAF:
         .    .    .         .    .    .         .    .    .  			{
         .    .    .         .    .    .         .    .    .  				Leaf* l = t->root.ptr.l;
         .    .    .         .    .    .         .    .    .  				entry_dump(l->item, l->sz, output, 0);
         .    .    .         .    .    .         .    .    .  			}
         .    .    .         .    .    .         .    .    .  			break;
         .    .    .         .    .    .         .    .    .  
         .    .    .         .    .    .         .    .    .  		case TYPE_BRANCH:
-- line 127 ----------------------------------------
-- line 128 ----------------------------------------
         .    .    .         .    .    .         .    .    .  			branch_dump(t->root.ptr.b, output, 0);
         .    .    .         .    .    .         .    .    .  			break;
         .    .    .         .    .    .         .    .    .  		
         .    .    .         .    .    .         .    .    .  		case TYPE_BRANCHLEAF:
         .    .    .         .    .    .         .    .    .  			branch_leaf_dump(t->root.ptr.bl, output, 0);
         .    .    .         .    .    .         .    .    .  			break;
         .    .    .         .    .    .         .    .    .  
         .    .    .         .    .    .         .    .    .  		case TYPE_BRANCHLEAF2:
         3    0    0         1    0    0         0    0    0  			branch_leaf_dump2(t->root.ptr.bl2, output, 0);
         .    .    .         .    .    .         .    .    .  			break;
         .    .    .         .    .    .         .    .    .  
         .    .    .         .    .    .         .    .    .  		default:
         .    .    .         .    .    .         .    .    .  			assert(0);
         .    .    .         .    .    .         .    .    .  	}
         .    .    .         .    .    .         .    .    .  }
         .    .    .         .    .    .         .    .    .  

--------------------------------------------------------------------------------
-- User-annotated source: /u/v/a/van-sandt/dev/fsort/6/branch.c
--------------------------------------------------------------------------------
        Ir I1mr ILmr         Dr      D1mr  DLmr         Dw  D1mw  DLmw 

         .    .    .          .         .     .          .     .     .  #include "branch.h"
         .    .    .          .         .     .          .     .     .  
         .    .    .          .         .     .          .     .     .  #include <stdio.h>
         .    .    .          .         .     .          .     .     .  #include <stdlib.h>
         .    .    .          .         .     .          .     .     .  #include <string.h>
         .    .    .          .         .     .          .     .     .  
         .    .    .          .         .     .          .     .     .  #include "leaf.h"
         .    .    .          .         .     .          .     .     .  
        63    1    1          0         0     0          0     0     0  Branch* branch_new() {
       189    0    0          0         0     0         63     0     0  	Branch* b = (Branch*)malloc(sizeof(Branch));
         .    .    .          .         .     .          .     .     .  	branch_init(b);
         .    .    .          .         .     .          .     .     .  
         .    .    .          .         .     .          .     .     .  	return b;
       126    0    0         63         0     0          0     0     0  }
         .    .    .          .         .     .          .     .     .  
         .    .    .          .         .     .          .     .     .  void branch_init(Branch *b) {
     8,064    0    0          0         0     0          0     0     0  	for (int i = 0; i < BRANCH_SZ; ++i) {
     8,064    0    0          0         0     0      4,032   578   135  		b->kid[i].type = TYPE_NONE;
         .    .    .          .         .     .          .     .     .  	}
       126    1    1          0         0     0        126     0     0  	b->numLeaves = b->numBranches = 0;
        63    0    0          0         0     0         63     0     0  	b->capacity = 0;
         .    .    .          .         .     .          .     .     .  }
         .    .    .          .         .     .          .     .     .  
         .    .    .          .         .     .          .     .     .  void branch_delete(Branch* b) {
         .    .    .          .         .     .          .     .     .  	for (int i = 0; i < BRANCH_SZ; ++i) {
         .    .    .          .         .     .          .     .     .  		switch (b->kid[i].type) {
         .    .    .          .         .     .          .     .     .  			case TYPE_LEAF:
         .    .    .          .         .     .          .     .     .  				if (b->capacity == 0) {
         .    .    .          .         .     .          .     .     .  					leaf_delete(b->kid[i].ptr.l);
-- line 29 ----------------------------------------
-- line 45 ----------------------------------------
         .    .    .          .         .     .          .     .     .  }
         .    .    .          .         .     .          .     .     .  
         .    .    .          .         .     .          .     .     .  void branch_leaf_delete(BranchLeaf* bl) {
         .    .    .          .         .     .          .     .     .  	for (int i = 0; i < BRANCH_SZ; i++) {
         .    .    .          .         .     .          .     .     .  		branch_leaf_delete_h(bl->kid + i);
         .    .    .          .         .     .          .     .     .  	}
         .    .    .          .         .     .          .     .     .  }
         .    .    .          .         .     .          .     .     .  
         9    1    1          0         0     0          7     0     0  void branch_leaf_delete2(BranchLeaf2* bl2) {
     8,192    0    0      4,096         0     0          0     0     0  	for (int i = 0; i < BRANCH_SZ2; i++) {
         .    .    .          .         .     .          .     .     .  		branch_leaf_delete_h(bl2->kid + i);
         .    .    .          .         .     .          .     .     .  	}
         8    0    0          7         1     0          0     0     0  }
         .    .    .          .         .     .          .     .     .  
         .    .    .          .         .     .          .     .     .  void branch_leaf_delete_h(Node* kid) {
    20,480    0    0      4,096     1,025   998          0     0     0  		switch (kid->type) {
         .    .    .          .         .     .          .     .     .  			case TYPE_BRANCH:
         .    .    .          .         .     .          .     .     .  				branch_delete(kid->ptr.b);
         .    .    .          .         .     .          .     .     .  				free(kid->ptr.b);
         .    .    .          .         .     .          .     .     .  				break;
         .    .    .          .         .     .          .     .     .  
         .    .    .          .         .     .          .     .     .  			case TYPE_BRANCHLEAF:
         .    .    .          .         .     .          .     .     .  				branch_leaf_delete(kid->ptr.bl);
     4,096    1    1          0         0     0          0     0     0  				free(kid->ptr.bl);
         .    .    .          .         .     .          .     .     .  				break;
         .    .    .          .         .     .          .     .     .  
         .    .    .          .         .     .          .     .     .  			case TYPE_LEAF:
         .    .    .          .         .     .          .     .     .  			case TYPE_NONE:
         .    .    .          .         .     .          .     .     .  				break;
         .    .    .          .         .     .          .     .     .  
         .    .    .          .         .     .          .     .     .  			default:
         .    .    .          .         .     .          .     .     .  				assert(0);
         .    .    .          .         .     .          .     .     .  		}
         .    .    .          .         .     .          .     .     .  #ifndef NDEBUG
         .    .    .          .         .     .          .     .     .  		kid->type = TYPE_NONE;
         .    .    .          .         .     .          .     .     .  #endif
         .    .    .          .         .     .          .     .     .  }
         .    .    .          .         .     .          .     .     .  
        11    1    1          0         0     0          7     0     0  Node branch_grow(Node n) {
         .    .    .          .         .     .          .     .     .  	assert(n.type == TYPE_BRANCH);
         .    .    .          .         .     .          .     .     .  	Branch* b = n.ptr.b;
         .    .    .          .         .     .          .     .     .  	assert(b->capacity == 0);
         .    .    .          .         .     .          .     .     .  	assert(b != NULL);
       185    1    1         62        27     0          0     0     0  	if (b->numLeaves >= BRANCH_MAXLEAVES) {
       369    1    1          0         0     0        245     0     0  		BranchLeaf* bl = malloc(sizeof(BranchLeaf));
       246    0    0        123         0     0         62     0     0  		bl->numBranches = b->numBranches;
         .    .    .          .         .     .          .     .     .  		memcpy(bl->kid, b->kid, sizeof(Node) * BRANCH_SZ);
     7,936    0    0          0         0     0          0     0     0  		for (int i = 0; i < BRANCH_SZ; i++) {
     7,936    0    0      3,968        73     0          0     0     0  			if (b->kid[i].type == TYPE_LEAF) {
     3,844    1    1      3,844         0     0          0     0     0  				Leaf* l = b->kid[i].ptr.l;
    15,252    1    1      7,626     1,974     0      7,626   247   240  				bl->sz[i] = l->sz;
     3,844    0    0          0         0     0          0     0     0  				memcpy(bl->e[i], l->item, l->sz * sizeof(Entry));
    26,660    1    1     15,128         0     0      3,844     0     0  				free(l);
         .    .    .          .         .     .          .     .     .  #ifndef NDEBUG
         .    .    .          .         .     .          .     .     .  				bl->kid[i].ptr.l = NULL;
         .    .    .          .         .     .          .     .     .  #endif
         .    .    .          .         .     .          .     .     .  			}
         .    .    .          .         .     .          .     .     .  		}
       246    1    1        122         0     0          0     0     0  		n.type = TYPE_BRANCHLEAF;
       369    0    0        122         0     0        245     0     0  		free(b);
         .    .    .          .         .     .          .     .     .  		n.ptr.bl = bl;
         .    .    .          .         .     .          .     .     .  	}
         .    .    .          .         .     .          .     .     .  
       370    0    0         62         1     0          0     0     0  	return n;
         9    0    0          7         1     0          0     0     0  }
         .    .    .          .         .     .          .     .     .  
   897,386    0    0         64         0     0    552,080    51     2  Node branch_leaf_grow(Node n) {
         .    .    .          .         .     .          .     .     .  	assert(n.type == TYPE_BRANCHLEAF);
         .    .    .          .         .     .          .     .     .  	BranchLeaf* bl = n.ptr.bl;
         .    .    .          .         .     .          .     .     .  	assert(bl != NULL);
         .    .    .          .         .     .          .     .     .  	// we can handle non full branch_leaves by popping leaves into branches
   138,020    0    0     69,010        23     0          0     0     0  	if (bl->numBranches >= BRANCHLEAF_GROWSZ) {
        13    1    1          2         0     0          4     0     0  		BranchLeaf2* bl2 = malloc(sizeof(BranchLeaf2));
       384    1    1        192         0     0          0     0     0  		for (int i = 0; i < BRANCH_SZ; i++) {
     8,192    0    0          0         0     0          0     0     0  			for (int j = 0; j < BRANCH_SZ; j++) {
     4,096    0    0      4,096         0     0          0     0     0  				Node kid = bl->kid[i];
         .    .    .          .         .     .          .     .     .  				Node gKid;
         .    .    .          .         .     .          .     .     .  				int sz;
         .    .    .          .         .     .          .     .     .  				Entry* dst = bl2->e[i * BRANCH_SZ + j];
    24,448    1    1      4,096        16     0          0     0     0  				switch (kid.type) {
         .    .    .          .         .     .          .     .     .  					case TYPE_BRANCH:
       384    1    1        192        17     6          0     0     0  						gKid = kid.ptr.b->kid[j];
       128    0    0          0         0     0          0     0     0  						switch (gKid.type) {
         .    .    .          .         .     .          .     .     .  							case TYPE_LEAF:
        62    0    0         62        39     0          0     0     0  								sz = gKid.ptr.l->sz;
       186    0    0          0         0     0         62     0     0  								memcpy(dst, gKid.ptr.l->item, sz * sizeof(Entry));
       186    0    0         62         0     0         62     0     0  								free(gKid.ptr.l);
       372    0    0        310         0     0          0     0     0  								break;
         .    .    .          .         .     .          .     .     .  
         .    .    .          .         .     .          .     .     .  							default:
         .    .    .          .         .     .          .     .     .  								sz = 0;
         .    .    .          .         .     .          .     .     .  						}
         .    .    .          .         .     .          .     .     .  						break;
         .    .    .          .         .     .          .     .     .  
         .    .    .          .         .     .          .     .     .  					case TYPE_BRANCHLEAF:
    27,328    0    0     11,712       975    69          0     0     0  						gKid = bl->kid[i].ptr.bl->kid[j];
     7,808    0    0          0         0     0          0     0     0  						switch (gKid.type) {
         .    .    .          .         .     .          .     .     .  							case TYPE_LEAF:
     3,782    1    1      3,782       305    37          0     0     0  								sz = kid.ptr.bl->sz[j];
    11,346    0    0          0         0     0      3,782     0     0  								memcpy(dst, kid.ptr.bl->e[j], sz * sizeof(Entry));
         .    .    .          .         .     .          .     .     .  								break;
         .    .    .          .         .     .          .     .     .  
         .    .    .          .         .     .          .     .     .  							default:
       124    0    0          0         0     0          0     0     0  								sz = 0;
         .    .    .          .         .     .          .     .     .  						}
         .    .    .          .         .     .          .     .     .  						break;
         .    .    .          .         .     .          .     .     .  
         .    .    .          .         .     .          .     .     .  					default:
         .    .    .          .         .     .          .     .     .  #ifndef NDEBUG
         .    .    .          .         .     .          .     .     .  						{
         .    .    .          .         .     .          .     .     .  							char z = 'z';
         .    .    .          .         .     .          .     .     .  							assert(i == 0 || i > lhash(&z));
         .    .    .          .         .     .          .     .     .  						}
         .    .    .          .         .     .          .     .     .  #endif
       256    0    0          0         0     0          0     0     0  						sz = 0;
       128    1    1          0         0     0          0     0     0  						gKid.type = TYPE_NONE;
         .    .    .          .         .     .          .     .     .  				}
    45,056    1    1          0         0     0      8,192 1,024 1,024  				bl2->kid[i*BRANCH_SZ + j] = gKid;
     4,096    0    0          0         0     0      4,096   257   257  				bl2->sz[i*BRANCH_SZ + j] = sz;
         .    .    .          .         .     .          .     .     .  			}
       256    1    1         64         0     0          0     0     0  			if (bl->kid[i].type == TYPE_BRANCHLEAF) {
       671    1    1        305         0     0        305     0     0  				free(bl->kid[i].ptr.bl);
         6    0    0          0         0     0          0     0     0  			} else if (bl->kid[i].type == TYPE_BRANCH) {
        11    0    0          5         0     0          5     0     0  				free(bl->kid[i].ptr.b);
         .    .    .          .         .     .          .     .     .  			}
         .    .    .          .         .     .          .     .     .  		}
         6    0    0          2         0     0          2     0     0  		free(bl);
         1    0    0          0         0     0          0     0     0  		n.type = TYPE_BRANCHLEAF2;
         .    .    .          .         .     .          .     .     .  		n.ptr.bl2 = bl2;
         .    .    .          .         .     .          .     .     .  	}
   276,040    1    1     69,010         0     0          0     0     0  	return n;
   552,080    0    0    483,070         2     2          0     0     0  }
         .    .    .          .         .     .          .     .     .  
         .    .    .          .         .     .          .     .     .  
         .    .    .          .         .     .          .     .     .  // depth is needed for the pop function
   645,750    2    2          0         0     0    387,450     0     0  Node branch_pull(Node* nb, hash2_t h, int* depth) {
    64,575    0    0     64,575         0     0          0     0     0  	Branch* b = nb->ptr.b;
         .    .    .          .         .     .          .     .     .  	assert(b != NULL && h < 63);
   452,025    0    0    193,725         0     0          0     0     0  	Node n = b->kid[h];
   129,150    0    0          0         0     0          0     0     0  	if (n.type == TYPE_NONE) {
     7,812    0    0          0         0     0      3,906     0     0  		n.ptr.l = leaf_new();
         .    .    .          .         .     .          .     .     .  		n.type = TYPE_LEAF;
    11,718    0    0      7,812         0     0          0     0     0  		b->numLeaves++;
    23,436    0    0          0         0     0      7,812     0     0  		b->kid[h] = n;
   121,338    0    0          0         0     0          0     0     0  	} else if (n.type == TYPE_LEAF) {
         .    .    .          .         .     .          .     .     .  		Leaf* l = n.ptr.l;
   182,007    0    0     60,669    10,095     0          0     0     0  		if (l->sz == LEAF_SZ) {
         .    .    .          .         .     .          .     .     .  			n.type = TYPE_BRANCH;
         .    .    .          .         .     .          .     .     .  			n.ptr.b = leaf_pop(l, *depth);
         .    .    .          .         .     .          .     .     .  			free(l);
         .    .    .          .         .     .          .     .     .  			b->numLeaves--;
         .    .    .          .         .     .          .     .     .  			b->numBranches++;
     3,906    1    1          0         0     0      3,906     9     0  			b->kid[h] = n;
         .    .    .          .         .     .          .     .     .  		}
         .    .    .          .         .     .          .     .     .  	} else if (n.type == TYPE_BRANCH) {
         .    .    .          .         .     .          .     .     .  		n = branch_grow(n);
         .    .    .          .         .     .          .     .     .  		b->kid[h] = n;
         .    .    .          .         .     .          .     .     .  	}
         .    .    .          .         .     .          .     .     .  
    64,575    0    0     64,575         0     0          0     0     0  	(*depth)++;
   193,725    1    1          0         0     0          0     0     0  	return n;
   581,175    0    0    452,025         0     0          0     0     0  }
         .    .    .          .         .     .          .     .     .  
   754,950    1    1          0         0     0    452,970     0     0  Node branch_leaf_pull(Node* nbl, hash2_t h, int* depth) {
    75,495    0    0     75,495         0     0          0     0     0  	BranchLeaf* bl = nbl->ptr.bl;
   679,455    1    1     75,495         0     0          0     0     0  	Node n = branch_leaf_pull_h(bl->kid + h, bl->e[h], bl->sz + h, *depth); 
       246    0    0          0         0     0          0     0     0  	if (n.type == TYPE_BRANCH) {
       124    0    0         62         6     0          0     0     0  		bl->numBranches++;
         .    .    .          .         .     .          .     .     .  	}
    75,495    1    1     75,495        76     0          0     0     0  	(*depth)++;
   226,485    0    0          0         0     0          0     0     0  	return n;
   603,960    0    0    528,465        80     0          0     0     0  }
         .    .    .          .         .     .          .     .     .  
         .    .    .          .         .     .          .     .     .  Node branch_leaf_pull_h(Node* n, Entry* entries, int* sz, int depth) {
         .    .    .          .         .     .          .     .     .  	Node r;
 6,016,380    0    0  2,005,460 1,615,207 1,234          0     0     0  	if (n->type == TYPE_LEAF) {
         .    .    .          .         .     .          .     .     .  		assert(*sz <= LEAF_SZ);
 5,996,925    0    0  1,998,975   970,726    25          0     0     0  		if (*sz == LEAF_SZ) {
       124    1    1          0         0     0        124     0     0  			n->type = TYPE_BRANCH;
       248    0    0          0         0     0        124     9     0  			n->ptr.b = entry_pop(entries, *sz, depth + 1);
         .    .    .          .         .     .          .     .     .  #ifndef NDEBUG
         .    .    .          .         .     .          .     .     .  			*sz = 0;
         .    .    .          .         .     .          .     .     .  #endif
       248    0    0        186        21     0          0     0     0  			r = *n;
         .    .    .          .         .     .          .     .     .  		} else {
 3,928,878    1    1          0         0     0          0     0     0  			r.type = TYPE_ENTRY;
 7,995,957    1    1  1,930,087         2     0        122     0     0  			r.ptr.e = entries + *sz;
 3,997,826    0    0          0         0     0  1,998,913     0     0  			(*sz)++;
         .    .    .          .         .     .          .     .     .  		}
    12,970    0    0          0         0     0          0     0     0  	} else if (n->type == TYPE_NONE) {
         .    .    .          .         .     .          .     .     .  		*sz = 0;
         .    .    .          .         .     .          .     .     .  		n->type = TYPE_LEAF;
         .    .    .          .         .     .          .     .     .  #ifndef NDEBUG
         .    .    .          .         .     .          .     .     .  		n->ptr.l = NULL;
         .    .    .          .         .     .          .     .     .  #endif
         .    .    .          .         .     .          .     .     .  		r.type = TYPE_ENTRY;
         .    .    .          .         .     .          .     .     .  		r.ptr.e = entries;
 1,998,975    2    2          0         0     0          0     0     0  		(*sz)++;
    12,970    0    0          0         0     0          0     0     0  	} else if (n->type == TYPE_BRANCH) {
       427    0    0         61         0     0        122     3     0  		*n = branch_grow(*n);
       122    0    0        122         0     0          0     0     0  		r = *n;
         .    .    .          .         .     .          .     .     .  	} else {
    12,848    0    0     12,848        49     0          0     0     0  		r = *n;
         .    .    .          .         .     .          .     .     .  	}
         .    .    .          .         .     .          .     .     .  
13,811,735    2    2          0         0     0          0     0     0  	return r;
         .    .    .          .         .     .          .     .     .  }
         .    .    .          .         .     .          .     .     .  
19,299,650    1    1          0         0     0 11,579,790   470     3  Node branch_leaf_pull2(Node* nbl2, hash2_t h, int* depth) {
 1,929,965    0    0  1,929,965         0     0          0     0     0  	BranchLeaf2* bl2 = nbl2->ptr.bl2;
17,369,685    1    1  1,929,965         0     0          0     0     0  	Node n = branch_leaf_pull_h(bl2->kid + h, bl2->e[h], bl2->sz + h, *depth);
 3,859,930    0    0          0         0     0  1,929,965     0     0  	(*depth) += 2;
 3,859,930    0    0          0         0     0          0     0     0  	return n;
15,439,720    0    0 13,509,755         0     0          0     0     0  }
         .    .    .          .         .     .          .     .     .  
         .    .    .          .         .     .          .     .     .  char* branch_dump(Branch* b, char* output, int depth) {
         .    .    .          .         .     .          .     .     .  #ifdef PRINT_TREE
         .    .    .          .         .     .          .     .     .  	int numChildren = 0;
         .    .    .          .         .     .          .     .     .  	for (int i = 0; i < BRANCH_SZ; ++i) {
         .    .    .          .         .     .          .     .     .  		if (b->kid[i].type != TYPE_NONE) {
         .    .    .          .         .     .          .     .     .  			++numChildren;
         .    .    .          .         .     .          .     .     .  		}
-- line 266 ----------------------------------------
-- line 311 ----------------------------------------
         .    .    .          .         .     .          .     .     .  	for (int i = 0; i < BRANCH_SZ; i++) {
         .    .    .          .         .     .          .     .     .  		output = branch_leaf_dump_h(output, bl->kid + i, bl->sz + i, bl->e[i], depth);
         .    .    .          .         .     .          .     .     .  	}
         .    .    .          .         .     .          .     .     .  
         .    .    .          .         .     .          .     .     .  	return output;
         .    .    .          .         .     .          .     .     .  }
         .    .    .          .         .     .          .     .     .  
         .    .    .          .         .     .          .     .     .  char* branch_leaf_dump_h(char* output, Node *n, int *sz, Entry *entries, int depth) {
    28,672    1    1      4,096     3,877 1,015          0     0     0  	switch (n->type) {
         .    .    .          .         .     .          .     .     .  		case TYPE_LEAF:
    39,196    0    0     23,568     7,688   246      3,844     0     0  			output = entry_dump(entries, *sz, output, depth + 1);
         .    .    .          .         .     .          .     .     .  			break;
         .    .    .          .         .     .          .     .     .  
         .    .    .          .         .     .          .     .     .  		case TYPE_BRANCH:
         1    0    0          0         0     0          0     0     0  			output = branch_dump(n->ptr.b, output, depth + 1);
         .    .    .          .         .     .          .     .     .  			break;
         .    .    .          .         .     .          .     .     .  
         .    .    .          .         .     .          .     .     .  		case TYPE_BRANCHLEAF:
         .    .    .          .         .     .          .     .     .  			output = branch_leaf_dump(n->ptr.bl, output, depth + 1);
         .    .    .          .         .     .          .     .     .  			break;
         .    .    .          .         .     .          .     .     .  
         .    .    .          .         .     .          .     .     .  		default:
         .    .    .          .         .     .          .     .     .  			;
         .    .    .          .         .     .          .     .     .  	}
         .    .    .          .         .     .          .     .     .  
         .    .    .          .         .     .          .     .     .  	return output;
         .    .    .          .         .     .          .     .     .  }
         .    .    .          .         .     .          .     .     .  
        15    2    2          0         0     0          9     0     0  char* branch_leaf_dump2(BranchLeaf2* bl2, char* output, int depth) {
         .    .    .          .         .     .          .     .     .  #ifdef PRINT_TREE
         .    .    .          .         .     .          .     .     .  	printf("bl2\n");
         .    .    .          .         .     .          .     .     .  #endif
     8,192    0    0      4,096         0     0          0     0     0  	for (int i = 0; i < BRANCH_SZ2; i++) {
         .    .    .          .         .     .          .     .     .  		output = branch_leaf_dump_h(output, bl2->kid + i, bl2->sz + i, bl2->e[i], depth + 1);
         .    .    .          .         .     .          .     .     .  	}
         .    .    .          .         .     .          .     .     .  	return output;
         8    1    1          7         1     1          0     0     0  }

--------------------------------------------------------------------------------
-- User-annotated source: /u/v/a/van-sandt/dev/fsort/6/entry.c
--------------------------------------------------------------------------------
       Ir I1mr ILmr        Dr      D1mr      DLmr        Dw      D1mw DLmw 

-- line 13 ----------------------------------------
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  #include <stdlib.h>
        .    .    .         .         .         .         .         .    .  #include <string.h>
        .    .    .         .         .         .         .         .    .  #include <stdio.h>
        .    .    .         .         .         .         .         .    .  #include <strings.h>
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  void entry_init(Entry* e, hash_t* h, const Entry* src) {
        .    .    .         .         .         .         .         .    .  	memcpy(e->h, h, NUM_HASHES);
4,129,024    0    0 2,064,512         0         0 2,064,512     6,651  365  	e->nl = src->nl;
4,129,024    0    0 2,064,512         0         0 2,064,512         0    0  	e->off = src->off;
6,193,536    0    0 4,129,024         0         0 2,064,512         0    0  	e->len = src->len;
        .    .    .         .         .         .         .         .    .  }
        .    .    .         .         .         .         .         .    .  
      756    1    1         0         0         0       441        21    0  Branch* entry_pop(Entry* e, int sz, int depth) {
        .    .    .         .         .         .         .         .    .  	assert(e != NULL && sz > 0);
      252    0    0         0         0         0       189        36    0  	Node n = { .type = TYPE_BRANCH, .ptr.b = branch_new()};
  194,859    1    1    64,638         0         0        63         0    0  	for (int i = 0; i < sz; i++) {
   64,512    0    0         0         0         0    64,512         0    0  		hash_t h = lhash(e[i].h + (depth % NUM_HASHES));
   64,512    0    0         0         0         0    64,512         0    0  		int leafDepth = depth + 1;
  322,560    1    1         0         0         0    64,512         0    0  		Node newLeaf = branch_pull(&n, h, &(leafDepth));
        .    .    .         .         .         .         .         .    .  		assert(newLeaf.type == TYPE_LEAF);
        .    .    .         .         .         .         .         .    .  		hash_t* hBuf;
        .    .    .         .         .         .         .         .    .  		if ((depth + 1) % NUM_HASHES == 0) {
        .    .    .         .         .         .         .         .    .  			hBuf = (hash_t*)e[i].nl + e[i].off + depth + 1;
        .    .    .         .         .         .         .         .    .  		} else {
        .    .    .         .         .         .         .         .    .  			hBuf = e[i].h;
        .    .    .         .         .         .         .         .    .  		}
  258,048    0    0         0         0         0    64,512         0    0  		leaf_put(newLeaf.ptr.l, hBuf, e + i);
        .    .    .         .         .         .         .         .    .  	}
        .    .    .         .         .         .         .         .    .  	return n.ptr.b;
      504    0    0       441        22         0         0         0    0  }
        .    .    .         .         .         .         .         .    .  
   34,596    1    1         0         0         0    23,064         0    0  char* entry_dump(Entry* e, int sz, char* output, int depth) {
        .    .    .         .         .         .         .         .    .  	// assumes that a SmallEntry is smaller than the line that it is representing
        .    .    .         .         .         .         .         .    .  	static SmallEntry buf[LEAF_SZ];
        .    .    .         .         .         .         .         .    .  	assert(e != NULL && output != NULL);
    7,688    0    0         0         0         0         0         0    0  	if (sz == 0) return output;
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  #ifdef PRINT_TREE
        .    .    .         .         .         .         .         .    .  	struct timespec timer;
        .    .    .         .         .         .         .         .    .  	for (int i = 0; i < depth; ++i) {
        .    .    .         .         .         .         .         .    .  		printf(" ");
        .    .    .         .         .         .         .         .    .  	}
        .    .    .         .         .         .         .         .    .  	printf("l %d\n", sz);
        .    .    .         .         .         .         .         .    .  #endif
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  	
   15,376    0    0         0         0         0         0         0    0  	if (sz < MIN_BUCKETSORT) {
        .    .    .         .         .         .         .         .    .  		entry_sort(e, sz, depth);
        .    .    .         .         .         .         .         .    .  		output = entry_copyLine(e, sz, output);
        .    .    .         .         .         .         .         .    .  	}
        .    .    .         .         .         .         .         .    .  	else
    7,688    0    0         0         0         0         0         0    0  	if (sz < MIN_BUCKETSORT2)
        .    .    .         .         .         .         .         .    .  	{
        .    .    .         .         .         .         .         .    .  		entry_sortBuf(e, buf, sz, depth);
        .    .    .         .         .         .         .         .    .  		output = smallentry_copyLine(e, buf, sz, output);
        .    .    .         .         .         .         .         .    .  	}
        .    .    .         .         .         .         .         .    .  	else {
   15,376    1    1         0         0         0     3,844         0    0  		entry_sortBuf2(e, buf, sz, depth);
        .    .    .         .         .         .         .         .    .  		output = smallentry_copyLine(e, buf, sz, output);
        .    .    .         .         .         .         .         .    .  	}
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  	return output;
   34,596    1    1    26,908     3,844         0         0         0    0  }
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  // 1. have a byte array to use memchr on
        .    .    .         .         .         .         .         .    .  // 2. have a bit array to use ffs on
        .    .    .         .         .         .         .         .    .  // 3. have a bit array to use intrinsic ffs on
   49,972    1    1         0         0         0    26,908     3,843    0  void entry_sortBuf2(Entry* src, SmallEntry* buf, int sz, int depth) {
        .    .    .         .         .         .         .         .    .  	assert(sz >= MIN_BUCKETSORT && src != NULL);
        .    .    .         .         .         .         .         .    .  	// this is necessary because we have to scan twice
        .    .    .         .         .         .         .         .    .  	// changing this to uint8_t adds a lot of instructions to _sort
        .    .    .         .         .         .         .         .    .  	static Count count[HASH2_RANGE/VEC_SZ];
        .    .    .         .         .         .         .         .    .  	static Used used[HASH2_RANGE];
        .    .    .         .         .         .         .         .    .  	static SmallEntry* unsorted[HASH2_RANGE];
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  	entry_count2(src, count, used, sz, depth);
   30,752    0    0     3,844         0         0     7,688         0    0  	int numUnsorted = entry_bucket2(src, buf, count, used, unsorted, sz, depth);
        .    .    .         .         .         .         .         .    .  
  270,886    0    0         0         0         0         0         0    0  	for (int i = 0; i < numUnsorted; i++) {
        .    .    .         .         .         .         .         .    .  		smallentry_sort(unsorted[i], count[i/VEC_SZ].v[i%VEC_SZ], depth + 2);
        .    .    .         .         .         .         .         .    .  	}
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  	return;
   30,752    0    0    26,908     3,843         0         0         0    0  }
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  void entry_count2(Entry* src, Count* count, Used* used, int sz, int depth) {
        .    .    .         .         .         .         .         .    .  	assert(NUM_HASHES == 4); // relying on it being a power of 2
        .    .    .         .         .         .         .         .    .  	memset(count, 0, sizeof(Count) * HASH2_RANGE / VEC_SZ);
        .    .    .         .         .         .         .         .    .  //	memset(used, 0, sizeof(Used) * HASH2_RANGE);
    7,688    0    0         0         0         0         0         0    0  	const int ix = depth & (NUM_HASHES - 1);
4,034,596    1    1         0         0         0         0         0    0  	for (int i = 0; i < sz; ++i) {
        .    .    .         .         .         .         .         .    .  		union {
        .    .    .         .         .         .         .         .    .  			hash2_t* h;
        .    .    .         .         .         .         .         .    .  			char* c;
        .    .    .         .         .         .         .         .    .  		} key;
        .    .    .         .         .         .         .         .    .  		key.c = (char*)src[i].h + ix;
8,000,000    0    0         0         0         0 4,000,000         0    0  		*(key.h) = lhash2(key.c);
        .    .    .         .         .         .         .         .    .  		hash2_t h = *(key.h);
        .    .    .         .         .         .         .         .    .  //		count[h] &= used[*(key.h)];
8,000,000    1    1 2,000,000    11,734         0         0         0    0  		count[h/VEC_SZ].v[h%VEC_SZ]++;
        .    .    .         .         .         .         .         .    .  //		used[h] = 0xFF;
        .    .    .         .         .         .         .         .    .  	}
        .    .    .         .         .         .         .         .    .  }
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  uint32_t bytesOff(Count* count) {
        .    .    .         .         .         .         .         .    .  	__m256i zero = _mm256_setzero_si256();
        .    .    .         .         .         .         .         .    .  	__m256i cmp = _mm256_cmpeq_epi8(count->i,zero); 
        .    .    .         .         .         .         .         .    .  	return _mm256_movemask_epi8(cmp);
        .    .    .         .         .         .         .         .    .  }
        .    .    .         .         .         .         .         .    .  
   61,504    2    2         0         0         0    26,908     3,844    1  int entry_bucket2(Entry* src, SmallEntry* dst, Count* count, Used* used, SmallEntry* unsorted[], int sz, int depth) {
        .    .    .         .         .         .         .         .    .  	static SmallEntry* usedH[HASH2_RANGE];
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  	assert((depth + 1) % NUM_HASHES != 0);
        .    .    .         .         .         .         .         .    .  
    3,844    0    0         0         0         0         0         0    0  	int numUsed = 0;
        .    .    .         .         .         .         .         .    .  	SmallEntry* bin = dst;
        .    .    .         .         .         .         .         .    .  	assert(HASH2_RANGE % (VEC_SZ * 2) == 0);
        .    .    .         .         .         .         .         .    .  	int i;
  492,032    0    0         0         0         0         0         0    0  	for (i = 0; i < HASH2_RANGE/VEC_SZ - 1; i += 2) {
  984,064    1    1         0         0         0         0         0    0  		uint64_t m = ~(bytesOff(count + i) | ((uint64_t)bytesOff(count + i + 1) << 32));
  495,876    0    0         0         0         0         0         0    0  		uint32_t n = ffsll(m) - 1;
7,786,377    1    1   238,270         0         0   238,270         0    0  		for (uint64_t j = n; j < VEC_SZ * 2; j++) {
1,870,321    0    0         0         0         0         0         0    0  			int h = i * VEC_SZ + j;
7,481,284    0    0 1,870,321         0         0         0         0    0  			if (count[i].v[j] >= 2) {
  247,822    1    1         0         0         0   123,911    17,169   33  				unsorted[numUsed] = bin;
  371,733    0    0   247,822         0         0   123,911         0    0  				count[0].v[numUsed] = count[i].v[j];
  123,911    0    0         0         0         0         0         0    0  				numUsed++;
        .    .    .         .         .         .         .         .    .  			}
3,740,642    0    0         0         0         0 1,870,321 1,238,241  496  			usedH[h] = bin;
5,610,963    0    0         0         0         0         0         0    0  			bin += count[i].v[j];
        .    .    .         .         .         .         .         .    .  
7,481,284    0    0         0         0         0         0         0    0  			n = ffsll((m >> j) >> 1) - 1;
1,870,321    0    0         0         0         0         0         0    0  			j += n;
        .    .    .         .         .         .         .         .    .  		}
        .    .    .         .         .         .         .         .    .  	}
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  //	Used* iter = memchr(used, 0xFF, HASH2_RANGE );
        .    .    .         .         .         .         .         .    .  //	//Used* iter = memchr(used, 0xFF, HASH2_RANGE * sizeof(Used));
        .    .    .         .         .         .         .         .    .  //	while (iter != NULL) {
        .    .    .         .         .         .         .         .    .  //		int i = iter - used;
        .    .    .         .         .         .         .         .    .  //		if (count[i] >= 2) {
-- line 155 ----------------------------------------
-- line 158 ----------------------------------------
        .    .    .         .         .         .         .         .    .  //			numUsed++;
        .    .    .         .         .         .         .         .    .  //		}
        .    .    .         .         .         .         .         .    .  //		usedH[i] = bin;
        .    .    .         .         .         .         .         .    .  //		bin += count[i];
        .    .    .         .         .         .         .         .    .  //		iter = memchr(iter + 1, 0xFF, (HASH2_RANGE - i - 1));
        .    .    .         .         .         .         .         .    .  //		//iter = memchr(iter + 1, 0xFF, (HASH2_RANGE - i - 1) * sizeof(Used));
        .    .    .         .         .         .         .         .    .  //	}
        .    .    .         .         .         .         .         .    .  
    7,688    0    0     3,844       125         0         0         0    0  	int ix = depth & (NUM_HASHES - 1);
        .    .    .         .         .         .         .         .    .  
4,038,440    1    1    11,532         0         0         0         0    0  	for (int i = 0; i < sz; i++) {
        .    .    .         .         .         .         .         .    .  		Entry* e = src + i;
        .    .    .         .         .         .         .         .    .  		hash2_t* h = (hash2_t*)(e->h + ix);
6,000,000    0    0 4,000,000 1,506,224         0         0         0    0  		SmallEntry* be = usedH[*h];
8,000,000    1    1 4,000,000 2,000,000 1,983,355 2,000,000   739,476  382  		be->c = ix >= (NUM_HASHES - 2) ?
4,000,000    0    0 2,000,000         0         0         0         0    0  			*(e->nl + e->off + depth + 2) :
        .    .    .         .         .         .         .         .    .  			e->h[ix + 2];
4,000,000    0    0 2,000,000         0         0 2,000,000         0    0  		be->nl = e->nl;
6,023,064    0    0 2,003,844         0         0 2,000,000         0    0  		be->off = e->off + depth + 2;
        .    .    .         .         .         .         .         .    .  //		be->off = e->off;
4,000,000    0    0 2,000,000         0         0 2,000,000         0    0  		be->len = e->len;
4,000,000    0    0 4,000,000         0         0         0         0    0  		usedH[*h]++;
        .    .    .         .         .         .         .         .    .  	}
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  	return numUsed;
   30,752    1    1    26,908     7,685         0         0         0    0  }
        .    .    .         .         .         .         .         .    .  //
        .    .    .         .         .         .         .         .    .  // TODO consider batching multiple items of the same kind into a single copy also in pop
        .    .    .         .         .         .         .         .    .  void entry_sortBuf(Entry* src, SmallEntry* buf, int sz, int depth) {
        .    .    .         .         .         .         .         .    .  	assert(sz >= MIN_BUCKETSORT && src != NULL);
        .    .    .         .         .         .         .         .    .  	static int count[BRANCH_SZ];
        .    .    .         .         .         .         .         .    .  	static SmallEntry* used[BRANCH_SZ];
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  	entry_count(src, count, sz, depth);
-- line 191 ----------------------------------------
-- line 306 ----------------------------------------
        .    .    .         .         .         .         .         .    .  }
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  void smallentry_sort(SmallEntry* src, int sz, int depth) {
        .    .    .         .         .         .         .         .    .  	assert(src != NULL);
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  	// TODO make it an unsigned
        .    .    .         .         .         .         .         .    .  	assert(sz >= 2);
        .    .    .         .         .         .         .         .    .  
  743,466    1    1   247,822    21,010         0   123,911         0    0  	qsort(src, sz, sizeof(SmallEntry), smallentry_hcmp);
        .    .    .         .         .         .         .         .    .  	return;
        .    .    .         .         .         .         .         .    .  }
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  char* smallentry_copyLine(Entry* src, SmallEntry* buf, int sz, char* output) {
6,011,532    1    1         0         0         0         0         0    0  	for (int i = 0; i < sz; ++i) {
        .    .    .         .         .         .         .         .    .  		SmallEntry* be = buf + i;
4,000,000    0    0 2,000,000   438,847         0         0         0    0  		size_t len = be->len + 1;
        .    .    .         .         .         .         .         .    .  		memcpy(output, be->nl, len);
2,000,000    0    0         0         0         0 2,000,000         0    0  		output[len - 1] = '\n';
2,000,000    0    0         0         0         0         0         0    0  		output += len;
        .    .    .         .         .         .         .         .    .  	}
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  	return output;
        .    .    .         .         .         .         .         .    .  }
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  int smallentry_hcmp(const void* v1, const void* v2) {
        .    .    .         .         .         .         .         .    .  	const SmallEntry* e1 = v1;
        .    .    .         .         .         .         .         .    .  	const SmallEntry* e2 = v2;
  133,626    1    1   133,626    21,708         0         0         0    0  	char r = e1->c - e2->c;
  273,969    0    0   267,252         0         0         0         0    0  	int len = e1->len - e1->off;
  276,208    0    0   267,252     3,950         0         0         0    0  	len = len < e2->len - e2->off ? len : e2->len - e2->off;
        .    .    .         .         .         .         .         .    .  
  412,073    0    0   138,104         0         0         0         0    0  	return r == 0 ? memcmp(e1->nl + e1->off, e2->nl + e2->off, len) : r;
        .    .    .         .         .         .         .         .    .  //	return e1->c != e2->c ? e1->c - e2->c :
        .    .    .         .         .         .         .         .    .  		
        .    .    .         .         .         .         .         .    .  //	return e1->c - e2->c;
  131,387    0    0   131,387         0         0         0         0    0  }
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  int smallentry_strcmp(const void* v1, const void* v2) {
        .    .    .         .         .         .         .         .    .  	const SmallEntry* be1 = v1;
        .    .    .         .         .         .         .         .    .  	const SmallEntry* be2 = v2;
        .    .    .         .         .         .         .         .    .  	char* key1 = be1->nl + be1->off;
        .    .    .         .         .         .         .         .    .  	char* key2 = be2->nl + be2->off;
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  	return strcmp(key1, key2);
-- line 349 ----------------------------------------

--------------------------------------------------------------------------------
Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 
--------------------------------------------------------------------------------
60    6    6 58   39   23 61   24    0  percentage of events annotated

==15651== Cachegrind, a cache and branch-prediction profiler
==15651== Copyright (C) 2002-2013, and GNU GPL'd, by Nicholas Nethercote et al.
==15651== Using Valgrind-3.10.1 and LibVEX; rerun with -h for copyright info
==15651== Command: ./Prof6 z2e6
==15651== 
--15651-- warning: L3 cache found, using its data for the LL simulation.
	seconds	percent
load  0.051346	 1.5%
token 1.538624	45.9%
sort  1.760613	52.5%
write 0.000247	 0.0%
total 3.350949
==15651== 
==15651== I   refs:      562,593,055
==15651== I1  misses:          1,257
==15651== LLi misses:          1,252
==15651== I1  miss rate:        0.00%
==15651== LLi miss rate:        0.00%
==15651== 
==15651== D   refs:      229,958,184  (137,344,595 rd   + 92,613,589 wr)
==15651== D1  misses:     25,316,845  ( 17,030,632 rd   +  8,286,213 wr)
==15651== LLd misses:     12,803,208  (  8,464,323 rd   +  4,338,885 wr)
==15651== D1  miss rate:        11.0% (       12.3%     +        8.9%  )
==15651== LLd miss rate:         5.5% (        6.1%     +        4.6%  )
==15651== 
==15651== LL refs:        25,318,102  ( 17,031,889 rd   +  8,286,213 wr)
==15651== LL misses:      12,804,460  (  8,465,575 rd   +  4,338,885 wr)
==15651== LL miss rate:          1.6% (        1.2%     +        4.6%  )
