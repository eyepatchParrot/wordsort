
--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         6291456 B, 64 B, 12-way associative
Command:          ./Prof6 z2e6
Data file:        cachegrind.out.15540
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   /u/v/a/van-sandt/dev/fsort/6/entry.c
                  /u/v/a/van-sandt/dev/fsort/6/trie.c
Auto-annotation:  off

--------------------------------------------------------------------------------
         Ir  I1mr  ILmr          Dr       D1mr      DLmr         Dw      D1mw      DLmw 
--------------------------------------------------------------------------------
569,859,228 1,259 1,254 128,655,737 15,752,394 8,464,396 84,323,099 8,282,242 4,338,036  PROGRAM TOTALS

--------------------------------------------------------------------------------
         Ir I1mr ILmr         Dr      D1mr      DLmr         Dw      D1mw      DLmw  file:function
--------------------------------------------------------------------------------
112,262,806   11   11 15,942,479   501,524     1,102 10,082,952       977         5  /u/v/a/van-sandt/dev/fsort/6/trie.c:trie_flush
 96,498,250    4    4 17,369,685 2,339,317     1,252 13,509,755       470         4  /u/v/a/van-sandt/dev/fsort/6/branch.c:branch_leaf_pull2
 78,721,922    6    6 22,402,541 3,515,668 1,983,352 10,383,321 1,998,833       912  /u/v/a/van-sandt/dev/fsort/6/entry.c:entry_bucket2
 64,644,461    5    5 18,172,130 4,986,090 3,469,565 16,164,380 3,542,015 3,538,933  /build/eglibc-oGUzwX/eglibc-2.19/string/../sysdeps/x86_64/multiarch/memcpy-sse2-unaligned.S:__memcpy_sse2_unaligned
 50,002,970    7    7  2,000,494 2,000,000 1,999,999  8,000,498   500,000     1,854  /u/v/a/van-sandt/dev/fsort/6/main.c:tokenizeLast
 30,000,000    3    3  4,000,000   499,998   499,998          0         0         0  /build/eglibc-oGUzwX/eglibc-2.19/string/../sysdeps/x86_64/memrchr.S:memrchr
 21,168,112    5    5  2,278,574    37,912         0  4,158,507     3,843         0  /u/v/a/van-sandt/dev/fsort/6/entry.c:entry_sortBuf2
 14,451,584    0    0  8,258,048         0         0  6,193,536     6,594       365  /u/v/a/van-sandt/dev/fsort/6/entry.c:entry_init
 14,126,852    4    4  2,026,908   442,691         0  2,026,908         0         0  /u/v/a/van-sandt/dev/fsort/6/entry.c:entry_dump
 12,283,053    9    9  3,335,098         0         0  2,030,606    13,582        16  /build/eglibc-oGUzwX/eglibc-2.19/stdlib/msort.c:msort_with_tmp.part.0
 12,000,000    1    1  8,000,000 1,292,573   502,547          0         0         0  /u/v/a/van-sandt/dev/fsort/6/hash.c:lhash2
 12,000,000    0    0  8,000,000     1,011         1          0         0         0  /u/v/a/van-sandt/dev/fsort/6/hash.c:lhash
 10,000,000    0    0  2,000,000         0         0  2,000,000         0         0  /usr/include/x86_64-linux-gnu/bits/string3.h:entry_dump
  7,434,660    6    6  1,115,199         0         0  1,982,576     7,686         0  /build/eglibc-oGUzwX/eglibc-2.19/stdlib/msort.c:qsort_r
  4,817,662    5    5    782,208         0         0    588,660         0         0  /build/eglibc-oGUzwX/eglibc-2.19/string/../sysdeps/x86_64/multiarch/../memcpy.S:__GI_memcpy
  4,270,025   31   27  4,269,881    17,700         9         59         3         1  ???:???
  4,129,024    1    1  2,064,512     1,024         0  2,064,512 1,952,438   790,814  /usr/include/x86_64-linux-gnu/bits/string3.h:entry_init
  4,000,000    0    0  2,000,000         0         0  2,000,000         0         0  /usr/include/x86_64-linux-gnu/bits/string3.h:tokenizeLast
  3,510,644   10   10    713,271    14,873         7    533,999       251       236  /u/v/a/van-sandt/dev/fsort/6/branch.c:branch_leaf_pull
  2,344,230    3    3    710,325     9,930         0    399,168         6         0  /u/v/a/van-sandt/dev/fsort/6/branch.c:branch_pull
  1,913,299   10   10    646,102     1,375       113    568,528     1,315     1,283  /u/v/a/van-sandt/dev/fsort/6/branch.c:branch_leaf_grow
  1,797,968    4    4      3,845         1         0  1,007,636   248,065     2,112  /build/eglibc-oGUzwX/eglibc-2.19/string/../sysdeps/x86_64/memset.S:memset
  1,479,940    1    1    492,032    19,543         0          0         0         0  /usr/lib/gcc/x86_64-linux-gnu/4.8/include/avx2intrin.h:entry_bucket2
  1,227,263    1    1    937,621    25,658         0          0         0         0  /u/v/a/van-sandt/dev/fsort/6/entry.c:smallentry_hcmp
    929,402    6    6    384,405     8,315         5        120         0         0  /build/eglibc-oGUzwX/eglibc-2.19/malloc/malloc.c:free
    841,050    3    3     64,953    16,168     1,733    193,977         4         1  /u/v/a/van-sandt/dev/fsort/6/entry.c:entry_pop
    802,919   61   61     97,297       598        19    125,317     4,101       663  /build/eglibc-oGUzwX/eglibc-2.19/malloc/malloc.c:_int_malloc
    590,391    1    1    262,396         0         0    131,198         0         0  /u/v/a/van-sandt/dev/fsort/6/leaf.c:leaf_put

--------------------------------------------------------------------------------
-- User-annotated source: /u/v/a/van-sandt/dev/fsort/6/trie.c
--------------------------------------------------------------------------------
        Ir I1mr ILmr        Dr    D1mr  DLmr        Dw D1mw DLmw 

-- line 5 ----------------------------------------
         .    .    .         .       .     .         .    .    .  #include <stdlib.h>
         .    .    .         .       .     .         .    .    .  #include <string.h>
         .    .    .         .       .     .         .    .    .  
         .    .    .         .       .     .         .    .    .  #include "constants.h"
         .    .    .         .       .     .         .    .    .  #include "sort.h"
         .    .    .         .       .     .         .    .    .  #include "leaf.h"
         .    .    .         .       .     .         .    .    .  
         .    .    .         .       .     .         .    .    .  void trie_init(Trie* t) {
         1    1    1         0       0     0         1    1    0  	t->root.type = TYPE_NONE;
         2    0    0         1       0     0         1    0    0  	t->root.ptr.l = NULL;
         .    .    .         .       .     .         .    .    .  }
         .    .    .         .       .     .         .    .    .  
         2    1    1         0       0     0         1    0    0  void trie_delete(Trie* t) {
         8    0    0         1       1     1         0    0    0  	switch (t->root.type) {
         .    .    .         .       .     .         .    .    .  		case TYPE_LEAF:
         .    .    .         .       .     .         .    .    .  			free(t->root.ptr.l);
         .    .    .         .       .     .         .    .    .  			break;
         .    .    .         .       .     .         .    .    .  
         .    .    .         .       .     .         .    .    .  		case TYPE_BRANCH:
         .    .    .         .       .     .         .    .    .  			branch_delete(t->root.ptr.b);
         .    .    .         .       .     .         .    .    .  			free(t->root.ptr.b);
         .    .    .         .       .     .         .    .    .  			break;
         .    .    .         .       .     .         .    .    .  
         .    .    .         .       .     .         .    .    .  		case TYPE_BRANCHLEAF:
         .    .    .         .       .     .         .    .    .  			branch_leaf_delete(t->root.ptr.bl);
         .    .    .         .       .     .         .    .    .  			free(t->root.ptr.bl);
         .    .    .         .       .     .         .    .    .  			break;
         .    .    .         .       .     .         .    .    .  
         .    .    .         .       .     .         .    .    .  		case TYPE_BRANCHLEAF2:
         2    0    0         1       0     0         1    0    0  			branch_leaf_delete2(t->root.ptr.bl2);
         2    0    0         1       1     0         0    0    0  			free(t->root.ptr.bl2);
         .    .    .         .       .     .         .    .    .  			break;
         .    .    .         .       .     .         .    .    .  
         .    .    .         .       .     .         .    .    .  		default:
         .    .    .         .       .     .         .    .    .  			assert(0);
         .    .    .         .       .     .         .    .    .  	}
         1    0    0         1       0     0         0    0    0  }
         .    .    .         .       .     .         .    .    .  
         .    .    .         .       .     .         .    .    .  #ifdef PROF_STACK
         .    .    .         .       .     .         .    .    .  // have a flush for each width buffer where width is the number of chars hashed
         .    .    .         .       .     .         .    .    .  // have a flush for full buffers and partial ones
 4,004,890    2    2         0       0     0     3,423  976    5  void trie_flush(Trie *t, Entry* buf, unsigned bufSz) {
         .    .    .         .       .     .         .    .    .  	// consolidate different size stacks into the highest size stack
         .    .    .         .       .     .         .    .    .  	// draw an entry pointer up from leaves and branches passing in only the next
         .    .    .         .       .     .         .    .    .  	// hash. 
         .    .    .         .       .     .         .    .    .  	// flush will allow us to have the trie start out as a leaf node. since the
         .    .    .         .       .     .         .    .    .  	// indirection won't be costly
         .    .    .         .       .     .         .    .    .  	// Squash tree to reduce indirection.
         .    .    .         .       .     .         .    .    .  	assert(t != NULL);
         .    .    .         .       .     .         .    .    .  	// TODO look at the asm for this loop
         .    .    .         .       .     .         .    .    .  	static void* freeBuf[BUF_SZ];
         .    .    .         .       .     .         .    .    .  	int freeBufSz = 0;
     1,467    0    0       489     489     1         0    0    0  	if (t->root.type == TYPE_NONE) {
         4    2    2         0       0     0         3    0    0  		t->root.type = TYPE_LEAF;
         6    0    0         2       0     0         2    0    0  		t->root.ptr.l = leaf_new();
         .    .    .         .       .     .         .    .    .  	}
 4,003,912    0    0 2,000,000       0     0       489    0    0  	for (int i = 0; i < bufSz; ++i) {
         .    .    .         .       .     .         .    .    .  		Entry* e = buf + i;
         .    .    .         .       .     .         .    .    .  		int depth = 0;
10,000,000    1    1 8,000,000      14     0         0    0    0  		Node n = t->root;
 4,000,000    0    0         0       0     0         0    0    0  		if (n.type == TYPE_LEAF) {
         .    .    .         .       .     .         .    .    .  			Leaf* oldL = t->root.ptr.l;
     7,175    0    0     2,050       0     0     1,025    0    0  			if (leaf_grow(&t->root, t->root.ptr.l, t->root.ptr.l->sz, t->root.ptr.l->capacity, 0)) {
         2    0    0         0       0     0         1    0    0  				free(oldL);
         4    0    0         3       0     0         0    0    0  				n = t->root;
         .    .    .         .       .     .         .    .    .  			}
         .    .    .         .       .     .         .    .    .  		}
 3,997,950    0    0         0       0     0         0    0    0  		else if (n.type == TYPE_BRANCH) {
         6    0    0         0       0     0         1    0    0  			n = branch_grow(n);
         .    .    .         .       .     .         .    .    .  			t->root = n;
         .    .    .         .       .     .         .    .    .  		}
 3,997,948    0    0         0       0     0         0    0    0  		else if (n.type == TYPE_BRANCHLEAF) {
   483,072    0    0         0       0     0    69,010    0    0  			n = branch_leaf_grow(n);
   276,044    0    0    69,011       0     0   138,022    1    0  			t->root = n;
         .    .    .         .       .     .         .    .    .  		}
         .    .    .         .       .     .         .    .    .  
12,016,569    0    0         0       0     0         0    0    0  		while (n.type == TYPE_BRANCH || n.type == TYPE_BRANCHLEAF || n.type == TYPE_BRANCHLEAF2) {
10,027,615    1    1 2,005,523 499,788 1,093 2,005,523    0    0  			hash_t h = lhash(e->h[depth % NUM_HASHES]);
 8,021,966    0    0         0       0     0         0    0    0  			switch (n.type) {
         .    .    .         .       .     .         .    .    .  				case TYPE_BRANCHLEAF:
   377,475    0    0         0       0     0    75,495    0    0  					n = branch_leaf_pull(n.ptr.bl, h, depth);
    75,495    0    0         0       0     0         0    0    0  					depth++;
         .    .    .         .       .     .         .    .    .  					break;
         .    .    .         .       .     .         .    .    .  
         .    .    .         .       .     .         .    .    .  				case TYPE_BRANCH:
       315    1    1         0       0     0        63    0    0  					n = branch_pull(n.ptr.b, h, depth);
        63    0    0         0       0     0         0    0    0  					depth++;
        63    0    0         0       0     0         0    0    0  					break;
         .    .    .         .       .     .         .    .    .  
         .    .    .         .       .     .         .    .    .  				default:
         .    .    .         .       .     .         .    .    .  					assert(n.type == TYPE_BRANCHLEAF2);
         .    .    .         .       .     .         .    .    .  					assert((depth + 1) % NUM_HASHES != 0); // we're only using a branchleaf2 for root, so...
 9,649,825    1    1 1,929,965       0     0 3,859,930    0    0  					hash_t h2 = lhash(e->h[(depth + 1) % NUM_HASHES]);
17,369,685    0    0 1,929,965       0     0 1,929,965    0    0  					n = branch_leaf_pull2(n.ptr.bl2, h, h2, depth);
 1,929,965    0    0         0       0     0         0    0    0  					depth += 2;
         .    .    .         .       .     .         .    .    .  			}
         .    .    .         .       .     .         .    .    .  
         .    .    .         .       .     .         .    .    .  			// why not branchleaf?
 4,011,170    0    0         0       0     0         0    0    0  			if (n.type == TYPE_BRANCH && (depth % NUM_HASHES == 0)) {
         .    .    .         .       .     .         .    .    .  				memcpy(e->h, e->nl + e->off + depth, NUM_HASHES);
         .    .    .         .       .     .         .    .    .  			}
         .    .    .         .       .     .         .    .    .  		}
         .    .    .         .       .     .         .    .    .  
         .    .    .         .       .     .         .    .    .  		hash_t* hBuf;
 4,000,000    1    1         0       0     0         0    0    0  		if (depth % NUM_HASHES == 0) {
     4,096    0    0     2,048     256     0         0    0    0  			hBuf = (hash_t*)e->nl + e->off + depth;
         .    .    .         .       .     .         .    .    .  		} else {
 2,000,000    0    0         0       0     0         0    0    0  			hBuf = e->h;
         .    .    .         .       .     .         .    .    .  		}
         .    .    .         .       .     .         .    .    .  		assert(n.type == TYPE_LEAF || n.type == TYPE_ENTRY);
 4,000,000    0    0         0       0     0         0    0    0  		if (n.type == TYPE_LEAF) {
 4,003,199    2    2         0       0     0     1,087    0    0  			leaf_put(n.ptr.l, hBuf, e);
         .    .    .         .       .     .         .    .    .  		} else {
         .    .    .         .       .     .         .    .    .  			// TODO rename to entry_set
 3,998,913    0    0         0       0     0 1,998,913    0    0  			entry_init(n.ptr.e, hBuf, e);
         .    .    .         .       .     .         .    .    .  		}
         .    .    .         .       .     .         .    .    .  	}
         .    .    .         .       .     .         .    .    .  	for (int i = 0; i < freeBufSz; i++) {
         .    .    .         .       .     .         .    .    .  		free(freeBuf[i]);
         .    .    .         .       .     .         .    .    .  	}
     3,912    0    0     3,423     977     8         0    0    0  }
         .    .    .         .       .     .         .    .    .  #endif
         .    .    .         .       .     .         .    .    .  
         .    .    .         .       .     .         .    .    .  void trie_dump(Trie* t, char* output) {
         .    .    .         .       .     .         .    .    .  	// consider making this work off of pull as well
         8    0    0         1       0     0         0    0    0  	switch (t->root.type) {
         .    .    .         .       .     .         .    .    .  		case TYPE_LEAF:
         .    .    .         .       .     .         .    .    .  			{
         .    .    .         .       .     .         .    .    .  				Leaf* l = t->root.ptr.l;
         .    .    .         .       .     .         .    .    .  				entry_dump(l->item, l->sz, output, 0);
         .    .    .         .       .     .         .    .    .  			}
         .    .    .         .       .     .         .    .    .  			break;
         .    .    .         .       .     .         .    .    .  
         .    .    .         .       .     .         .    .    .  		case TYPE_BRANCH:
-- line 138 ----------------------------------------
-- line 139 ----------------------------------------
         .    .    .         .       .     .         .    .    .  			branch_dump(t->root.ptr.b, output, 0);
         .    .    .         .       .     .         .    .    .  			break;
         .    .    .         .       .     .         .    .    .  		
         .    .    .         .       .     .         .    .    .  		case TYPE_BRANCHLEAF:
         .    .    .         .       .     .         .    .    .  			branch_leaf_dump(t->root.ptr.bl, output, 0);
         .    .    .         .       .     .         .    .    .  			break;
         .    .    .         .       .     .         .    .    .  
         .    .    .         .       .     .         .    .    .  		case TYPE_BRANCHLEAF2:
         3    0    0         1       0     0         0    0    0  			branch_leaf_dump2(t->root.ptr.bl2, output, 0);
         .    .    .         .       .     .         .    .    .  			break;
         .    .    .         .       .     .         .    .    .  
         .    .    .         .       .     .         .    .    .  		default:
         .    .    .         .       .     .         .    .    .  			assert(0);
         .    .    .         .       .     .         .    .    .  	}
         .    .    .         .       .     .         .    .    .  }
         .    .    .         .       .     .         .    .    .  

--------------------------------------------------------------------------------
-- User-annotated source: /u/v/a/van-sandt/dev/fsort/6/entry.c
--------------------------------------------------------------------------------
       Ir I1mr ILmr        Dr      D1mr      DLmr        Dw      D1mw DLmw 

-- line 13 ----------------------------------------
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  #include <stdlib.h>
        .    .    .         .         .         .         .         .    .  #include <string.h>
        .    .    .         .         .         .         .         .    .  #include <stdio.h>
        .    .    .         .         .         .         .         .    .  #include <strings.h>
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  void entry_init(Entry* e, hash_t* h, const Entry* src) {
        .    .    .         .         .         .         .         .    .  	memcpy(e->h, h, NUM_HASHES);
4,129,024    0    0 2,064,512         0         0 2,064,512     6,594  365  	e->nl = src->nl;
4,129,024    0    0 2,064,512         0         0 2,064,512         0    0  	e->off = src->off;
6,193,536    0    0 4,129,024         0         0 2,064,512         0    0  	e->len = src->len;
        .    .    .         .         .         .         .         .    .  }
        .    .    .         .         .         .         .         .    .  
      630    1    1         0         0         0       378         4    1  Branch* entry_pop(Entry* e, int sz, int depth) {
        .    .    .         .         .         .         .         .    .  	assert(e != NULL && sz > 0);
      189    0    0         0         0         0        63         0    0  	Branch* b = branch_new();
  130,032    1    1         0         0         0         0         0    0  	for (int i = 0; i < sz; i++) {
  129,024    0    0    64,512    16,146     1,733    64,512         0    0  		hash_t h = lhash(e[i].h[depth % NUM_HASHES]);
  387,072    0    0         0         0         0    64,512         0    0  		Node newLeaf = branch_pull(b, h, depth + 1);
        .    .    .         .         .         .         .         .    .  		assert(newLeaf.type == TYPE_LEAF);
        .    .    .         .         .         .         .         .    .  		hash_t* hBuf;
        .    .    .         .         .         .         .         .    .  		if ((depth + 1) % NUM_HASHES == 0) {
        .    .    .         .         .         .         .         .    .  			hBuf = (hash_t*)e[i].nl + e[i].off + depth + 1;
        .    .    .         .         .         .         .         .    .  		} else {
        .    .    .         .         .         .         .         .    .  			hBuf = e[i].h;
        .    .    .         .         .         .         .         .    .  		}
  193,536    0    0         0         0         0    64,512         0    0  		leaf_put(newLeaf.ptr.l, hBuf, e + i);
        .    .    .         .         .         .         .         .    .  	}
        .    .    .         .         .         .         .         .    .  	return b;
      567    1    1       441        22         0         0         0    0  }
        .    .    .         .         .         .         .         .    .  
   34,596    1    1         0         0         0    23,064         0    0  char* entry_dump(Entry* e, int sz, char* output, int depth) {
        .    .    .         .         .         .         .         .    .  	// assumes that a SmallEntry is smaller than the line that it is representing
        .    .    .         .         .         .         .         .    .  	static SmallEntry buf[LEAF_SZ];
        .    .    .         .         .         .         .         .    .  	assert(e != NULL && output != NULL);
    7,688    0    0         0         0         0         0         0    0  	if (sz == 0) return output;
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  #ifdef PRINT_TREE
        .    .    .         .         .         .         .         .    .  	struct timespec timer;
        .    .    .         .         .         .         .         .    .  	for (int i = 0; i < depth; ++i) {
        .    .    .         .         .         .         .         .    .  		printf(" ");
        .    .    .         .         .         .         .         .    .  	}
        .    .    .         .         .         .         .         .    .  	printf("l %d\n", sz);
        .    .    .         .         .         .         .         .    .  #endif
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  	
   15,376    1    1         0         0         0         0         0    0  	if (sz < MIN_BUCKETSORT) {
        .    .    .         .         .         .         .         .    .  		entry_sort(e, sz, depth);
        .    .    .         .         .         .         .         .    .  		output = entry_copyLine(e, sz, output);
        .    .    .         .         .         .         .         .    .  	}
        .    .    .         .         .         .         .         .    .  	else
    7,688    0    0         0         0         0         0         0    0  	if (sz < MIN_BUCKETSORT2)
        .    .    .         .         .         .         .         .    .  	{
        .    .    .         .         .         .         .         .    .  		entry_sortBuf(e, buf, sz, depth);
        .    .    .         .         .         .         .         .    .  		output = smallentry_copyLine(e, buf, sz, output);
        .    .    .         .         .         .         .         .    .  	}
        .    .    .         .         .         .         .         .    .  	else {
   15,376    1    1         0         0         0     3,844         0    0  		entry_sortBuf2(e, buf, sz, depth);
        .    .    .         .         .         .         .         .    .  		output = smallentry_copyLine(e, buf, sz, output);
        .    .    .         .         .         .         .         .    .  	}
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  	return output;
   34,596    0    0    26,908     3,844         0         0         0    0  }
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  // 1. have a byte array to use memchr on
        .    .    .         .         .         .         .         .    .  // 2. have a bit array to use ffs on
        .    .    .         .         .         .         .         .    .  // 3. have a bit array to use intrinsic ffs on
   49,972    2    2         0         0         0    26,908     3,843    0  void entry_sortBuf2(Entry* src, SmallEntry* buf, int sz, int depth) {
        .    .    .         .         .         .         .         .    .  	assert(sz >= MIN_BUCKETSORT && src != NULL);
        .    .    .         .         .         .         .         .    .  	// this is necessary because we have to scan twice
        .    .    .         .         .         .         .         .    .  	// changing this to uint8_t adds a lot of instructions to _sort
        .    .    .         .         .         .         .         .    .  	static Count count[HASH2_RANGE/VEC_SZ];
        .    .    .         .         .         .         .         .    .  	static Used used[HASH2_RANGE];
        .    .    .         .         .         .         .         .    .  	static SmallEntry* unsorted[HASH2_RANGE];
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  	entry_count2(src, count, used, sz, depth);
   30,752    1    1     3,844         0         0     7,688         0    0  	int numUnsorted = entry_bucket2(src, buf, count, used, unsorted, sz, depth);
        .    .    .         .         .         .         .         .    .  
  270,886    0    0         0         0         0         0         0    0  	for (int i = 0; i < numUnsorted; i++) {
        .    .    .         .         .         .         .         .    .  		smallentry_sort(unsorted[i], count[i/VEC_SZ].v[i%VEC_SZ], depth + 2);
        .    .    .         .         .         .         .         .    .  	}
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  	return;
   30,752    0    0    26,908     3,844         0         0         0    0  }
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  void entry_count2(Entry* src, Count* count, Used* used, int sz, int depth) {
        .    .    .         .         .         .         .         .    .  	assert(NUM_HASHES == 4); // relying on it being a power of 2
        .    .    .         .         .         .         .         .    .  	memset(count, 0, sizeof(Count) * HASH2_RANGE / VEC_SZ);
        .    .    .         .         .         .         .         .    .  //	memset(used, 0, sizeof(Used) * HASH2_RANGE);
    7,688    0    0         0         0         0         0         0    0  	const int ix = depth & (NUM_HASHES - 1);
4,034,596    0    0         0         0         0         0         0    0  	for (int i = 0; i < sz; ++i) {
        .    .    .         .         .         .         .         .    .  		union {
        .    .    .         .         .         .         .         .    .  			hash2_t* h;
        .    .    .         .         .         .         .         .    .  			char* c;
        .    .    .         .         .         .         .         .    .  		} key;
        .    .    .         .         .         .         .         .    .  		key.c = (char*)src[i].h + ix;
8,000,000    1    1         0         0         0 4,000,000         0    0  		*(key.h) = lhash2(key.c);
        .    .    .         .         .         .         .         .    .  		hash2_t h = *(key.h);
        .    .    .         .         .         .         .         .    .  //		count[h] &= used[*(key.h)];
8,000,000    0    0 2,000,000    13,058         0         0         0    0  		count[h/VEC_SZ].v[h%VEC_SZ]++;
        .    .    .         .         .         .         .         .    .  //		used[h] = 0xFF;
        .    .    .         .         .         .         .         .    .  	}
        .    .    .         .         .         .         .         .    .  }
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  uint32_t bytesOff(Count* count) {
        .    .    .         .         .         .         .         .    .  	__m256i zero = _mm256_setzero_si256();
        .    .    .         .         .         .         .         .    .  	__m256i cmp = _mm256_cmpeq_epi8(count->i,zero); 
        .    .    .         .         .         .         .         .    .  	return _mm256_movemask_epi8(cmp);
        .    .    .         .         .         .         .         .    .  //	return _mm256_movemask_epi8(_mm256_cmpeq_epi8(count->i, _mm256_setzero_si256()));
        .    .    .         .         .         .         .         .    .  }
        .    .    .         .         .         .         .         .    .  
   61,504    1    1         0         0         0    26,908     3,844    1  int entry_bucket2(Entry* src, SmallEntry* dst, Count* count, Used* used, SmallEntry* unsorted[], int sz, int depth) {
        .    .    .         .         .         .         .         .    .  	static SmallEntry* usedH[HASH2_RANGE];
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  	assert((depth + 1) % NUM_HASHES != 0);
        .    .    .         .         .         .         .         .    .  
    3,844    0    0         0         0         0         0         0    0  	int numUsed = 0;
        .    .    .         .         .         .         .         .    .  	SmallEntry* bin = dst;
        .    .    .         .         .         .         .         .    .  	assert(HASH2_RANGE % (VEC_SZ * 2) == 0);
        .    .    .         .         .         .         .         .    .  	int i;
  492,032    0    0         0         0         0         0         0    0  	for (i = 0; i < HASH2_RANGE/VEC_SZ - 1; i += 2) {
        .    .    .         .         .         .         .         .    .  //		uint16_t m = ~_mm_movemask_epi8(_mm_cmpeq_epi8(count[i].i, _mm_setzero_si128()));
  984,064    0    0         0         0         0         0         0    0  		uint64_t m = ~(bytesOff(count + i) | ((uint64_t)bytesOff(count + i + 1) << 32));
        .    .    .         .         .         .         .         .    .  
  495,876    0    0         0         0         0         0         0    0  		uint32_t n = ffsll(m) - 1;
        .    .    .         .         .         .         .         .    .  //		m = m >> n;
7,786,377    2    2   238,270         0         0   238,270         0    0  		for (uint64_t j = n; j < VEC_SZ * 2; j++) {
        .    .    .         .         .         .         .         .    .  //		int j = 0;
        .    .    .         .         .         .         .         .    .  //		int n;
        .    .    .         .         .         .         .         .    .  //		while ((n = ffs(m) - 1) >= 0) {
        .    .    .         .         .         .         .         .    .  //			// can eliminate n if m doesn't change
        .    .    .         .         .         .         .         .    .  //			m = (m >> n) >> 1;
        .    .    .         .         .         .         .         .    .  //			j += n;
        .    .    .         .         .         .         .         .    .  			
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  //		for (int j = 0; j < VEC_SZ; j++) {
1,870,321    0    0         0         0         0         0         0    0  			int h = i * VEC_SZ + j;
7,481,284    0    0 1,870,321         0         0         0         0    0  			if (count[i].v[j] >= 2) {
  247,822    0    0         0         0         0   123,911    17,169   33  				unsorted[numUsed] = bin;
  371,733    0    0   247,822         0         0   123,911         0    0  				count[0].v[numUsed] = count[i].v[j];
  123,911    0    0         0         0         0         0         0    0  				numUsed++;
        .    .    .         .         .         .         .         .    .  			}
3,740,642    0    0         0         0         0 1,870,321 1,238,241  496  			usedH[h] = bin;
5,610,963    0    0         0         0         0         0         0    0  			bin += count[i].v[j];
        .    .    .         .         .         .         .         .    .  
7,481,284    0    0         0         0         0         0         0    0  			n = ffsll((m >> j) >> 1) - 1;
1,870,321    0    0         0         0         0         0         0    0  			j += n;
        .    .    .         .         .         .         .         .    .  		}
        .    .    .         .         .         .         .         .    .  	}
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  //	Used* iter = memchr(used, 0xFF, HASH2_RANGE );
        .    .    .         .         .         .         .         .    .  //	//Used* iter = memchr(used, 0xFF, HASH2_RANGE * sizeof(Used));
        .    .    .         .         .         .         .         .    .  //	while (iter != NULL) {
        .    .    .         .         .         .         .         .    .  //		int i = iter - used;
        .    .    .         .         .         .         .         .    .  //		if (count[i] >= 2) {
-- line 167 ----------------------------------------
-- line 170 ----------------------------------------
        .    .    .         .         .         .         .         .    .  //			numUsed++;
        .    .    .         .         .         .         .         .    .  //		}
        .    .    .         .         .         .         .         .    .  //		usedH[i] = bin;
        .    .    .         .         .         .         .         .    .  //		bin += count[i];
        .    .    .         .         .         .         .         .    .  //		iter = memchr(iter + 1, 0xFF, (HASH2_RANGE - i - 1));
        .    .    .         .         .         .         .         .    .  //		//iter = memchr(iter + 1, 0xFF, (HASH2_RANGE - i - 1) * sizeof(Used));
        .    .    .         .         .         .         .         .    .  //	}
        .    .    .         .         .         .         .         .    .  
    7,688    0    0     3,844       125         0         0         0    0  	int ix = depth & (NUM_HASHES - 1);
        .    .    .         .         .         .         .         .    .  
4,038,440    1    1    11,532         0         0         0         0    0  	for (int i = 0; i < sz; i++) {
        .    .    .         .         .         .         .         .    .  		Entry* e = src + i;
        .    .    .         .         .         .         .         .    .  		hash2_t* h = (hash2_t*)(e->h + ix);
6,000,000    0    0 4,000,000 1,507,858         0         0         0    0  		SmallEntry* be = usedH[*h];
8,000,000    1    1 4,000,000 2,000,000 1,983,352 2,000,000   739,579  382  		be->c = ix >= (NUM_HASHES - 2) ?
4,000,000    0    0 2,000,000         0         0         0         0    0  			*(e->nl + e->off + depth + 2) :
        .    .    .         .         .         .         .         .    .  			e->h[ix + 2];
4,000,000    0    0 2,000,000         0         0 2,000,000         0    0  		be->nl = e->nl;
6,023,064    0    0 2,003,844         0         0 2,000,000         0    0  		be->off = e->off + depth + 2;
        .    .    .         .         .         .         .         .    .  //		be->off = e->off;
4,000,000    1    1 2,000,000         0         0 2,000,000         0    0  		be->len = e->len;
4,000,000    0    0 4,000,000         0         0         0         0    0  		usedH[*h]++;
        .    .    .         .         .         .         .         .    .  	}
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  	return numUsed;
   30,752    0    0    26,908     7,685         0         0         0    0  }
        .    .    .         .         .         .         .         .    .  //
        .    .    .         .         .         .         .         .    .  // TODO consider batching multiple items of the same kind into a single copy also in pop
        .    .    .         .         .         .         .         .    .  void entry_sortBuf(Entry* src, SmallEntry* buf, int sz, int depth) {
        .    .    .         .         .         .         .         .    .  	assert(sz >= MIN_BUCKETSORT && src != NULL);
        .    .    .         .         .         .         .         .    .  	static int count[BRANCH_SZ];
        .    .    .         .         .         .         .         .    .  	static SmallEntry* used[BRANCH_SZ];
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  	entry_count(src, count, sz, depth);
-- line 203 ----------------------------------------
-- line 318 ----------------------------------------
        .    .    .         .         .         .         .         .    .  }
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  void smallentry_sort(SmallEntry* src, int sz, int depth) {
        .    .    .         .         .         .         .         .    .  	assert(src != NULL);
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  	// TODO make it an unsigned
        .    .    .         .         .         .         .         .    .  	assert(sz >= 2);
        .    .    .         .         .         .         .         .    .  
  743,466    1    1   247,822    21,010         0   123,911         0    0  	qsort(src, sz, sizeof(SmallEntry), smallentry_hcmp);
        .    .    .         .         .         .         .         .    .  	return;
        .    .    .         .         .         .         .         .    .  }
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  char* smallentry_copyLine(Entry* src, SmallEntry* buf, int sz, char* output) {
6,011,532    1    1         0         0         0         0         0    0  	for (int i = 0; i < sz; ++i) {
        .    .    .         .         .         .         .         .    .  		SmallEntry* be = buf + i;
4,000,000    0    0 2,000,000   438,847         0         0         0    0  		size_t len = be->len + 1;
        .    .    .         .         .         .         .         .    .  		memcpy(output, be->nl, len);
2,000,000    0    0         0         0         0 2,000,000         0    0  		output[len - 1] = '\n';
2,000,000    0    0         0         0         0         0         0    0  		output += len;
        .    .    .         .         .         .         .         .    .  	}
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  	return output;
        .    .    .         .         .         .         .         .    .  }
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  int smallentry_hcmp(const void* v1, const void* v2) {
        .    .    .         .         .         .         .         .    .  	const SmallEntry* e1 = v1;
        .    .    .         .         .         .         .         .    .  	const SmallEntry* e2 = v2;
  133,626    1    1   133,626    21,708         0         0         0    0  	char r = e1->c - e2->c;
  273,969    0    0   267,252         0         0         0         0    0  	int len = e1->len - e1->off;
  276,208    0    0   267,252     3,950         0         0         0    0  	len = len < e2->len - e2->off ? len : e2->len - e2->off;
        .    .    .         .         .         .         .         .    .  
  412,073    0    0   138,104         0         0         0         0    0  	return r == 0 ? memcmp(e1->nl + e1->off, e2->nl + e2->off, len) : r;
        .    .    .         .         .         .         .         .    .  //	return e1->c != e2->c ? e1->c - e2->c :
        .    .    .         .         .         .         .         .    .  		
        .    .    .         .         .         .         .         .    .  //	return e1->c - e2->c;
  131,387    0    0   131,387         0         0         0         0    0  }
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  int smallentry_strcmp(const void* v1, const void* v2) {
        .    .    .         .         .         .         .         .    .  	const SmallEntry* be1 = v1;
        .    .    .         .         .         .         .         .    .  	const SmallEntry* be2 = v2;
        .    .    .         .         .         .         .         .    .  	char* key1 = be1->nl + be1->off;
        .    .    .         .         .         .         .         .    .  	char* key2 = be2->nl + be2->off;
        .    .    .         .         .         .         .         .    .  
        .    .    .         .         .         .         .         .    .  	return strcmp(key1, key2);
-- line 361 ----------------------------------------

--------------------------------------------------------------------------------
Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 
--------------------------------------------------------------------------------
43    3    3 40   29   23 39   24    0  percentage of events annotated

==15540== Cachegrind, a cache and branch-prediction profiler
==15540== Copyright (C) 2002-2013, and GNU GPL'd, by Nicholas Nethercote et al.
==15540== Using Valgrind-3.10.1 and LibVEX; rerun with -h for copyright info
==15540== Command: ./Prof6 z2e6
==15540== 
--15540-- warning: L3 cache found, using its data for the LL simulation.
	seconds	percent
load  0.050198	 1.5%
token 1.453423	44.8%
sort  1.743001	53.7%
write 0.000260	 0.0%
total 3.247002
==15540== 
==15540== I   refs:      569,859,228
==15540== I1  misses:          1,259
==15540== LLi misses:          1,254
==15540== I1  miss rate:        0.00%
==15540== LLi miss rate:        0.00%
==15540== 
==15540== D   refs:      212,978,836  (128,655,737 rd   + 84,323,099 wr)
==15540== D1  misses:     24,034,636  ( 15,752,394 rd   +  8,282,242 wr)
==15540== LLd misses:     12,802,432  (  8,464,396 rd   +  4,338,036 wr)
==15540== D1  miss rate:        11.2% (       12.2%     +        9.8%  )
==15540== LLd miss rate:         6.0% (        6.5%     +        5.1%  )
==15540== 
==15540== LL refs:        24,035,895  ( 15,753,653 rd   +  8,282,242 wr)
==15540== LL misses:      12,803,686  (  8,465,650 rd   +  4,338,036 wr)
==15540== LL miss rate:          1.6% (        1.2%     +        5.1%  )
